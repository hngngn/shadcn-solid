import fs from "node:fs";
import path from "node:path";
import { rimraf } from "rimraf";
import * as v from "valibot";

import type { Registry } from "./registry/schema";
import { registrySchema } from "./registry/schema";
import { registry } from "./registry";
import { frameworks } from "./registry/frameworks";

const createComponentName = (itemName: string) =>
  itemName
    .split("-")
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join("");

const readFileContent = (filePath: string) => {
  try {
    return fs.readFileSync(filePath, "utf-8");
  } catch {
    return "";
  }
};

export const buildRegistry = (registry: Registry) => {
  for (const f of frameworks) {
    const isUno = f.name === "unocss";
    const outputDir = isUno
      ? "apps/unocss-playground/src/registry"
      : "apps/docs/src/registry";

    let componentImports = "";
    let index = `// @ts-nocheck
// Auto-generated by scripts/index.ts
// Do not edit this file directly.
    
export const Index: Record<string, any> = {\n`;
    const componentMap = new Map<string, { name: string; path: string }>();
    index += `  "${f.name}": {\n`;

    for (const item of registry.items) {
      if (isUno && item.type !== "registry:ui") continue;
      if (
        !isUno &&
        item.type !== "registry:example" &&
        item.type !== "registry:block"
      )
        continue;

      const files = item.files?.map((file) => {
        const filePath =
          typeof file === "string"
            ? `${outputDir}/${file}`
            : `${outputDir}/${file.path}`;
        const absPath = path.resolve(filePath);
        const content =
          !isUno && item.type === "registry:block"
            ? readFileContent(absPath)
            : "";
        return {
          path: typeof file === "string" ? file : file.path,
          type: typeof file === "string" ? "registry:page" : file.type,
          target: typeof file === "string" ? "" : (file.target ?? ""),
          ...(content ? { content } : {}),
        };
      });

      if (!files?.length) continue;

      const componentName = createComponentName(item.name);
      const componentKey = `${f.name}_${item.name}`;
      const componentPath = `@/registry/${files[0].path.replace(/\.tsx?$/, "")}`;

      if (!isUno) {
        componentMap.set(componentKey, {
          name: componentName,
          path: componentPath,
        });
      }

      index += `    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: ${JSON.stringify(files, null, 6)}${
        !isUno
          ? `,
      component: () => <${componentName} />,
      source: "${componentPath}.tsx"`
          : ""
      }
    },\n`;
    }

    index += `  }\n`;
    index += `}\n`;

    if (!isUno) {
      for (const [, c] of componentMap) {
        componentImports += `const ${c.name} = clientOnlyWrapper(() => import("${c.path}"), { lazy: true })\n`;
      }
      componentImports =
        `import clientOnlyWrapper from "@/components/client-only-wrapper"\n\n` +
        componentImports +
        "\n";
    }

    const finalIndex = componentImports + index;
    fs.mkdirSync(outputDir, { recursive: true });
    const outputFile = path.join(outputDir, "__index__.tsx");
    rimraf.sync(outputFile);
    fs.writeFileSync(outputFile, finalIndex);
    console.log(`‚úÖ Built registry for ${f.name} ‚Üí ${outputFile}`);
  }
};

try {
  console.log("üíΩ Building registry...");
  const result = v.safeParse(registrySchema, registry);
  if (!result.success) {
    console.error(result.issues);
    process.exit(1);
  }
  buildRegistry(result.output);
  console.log("üèÅ Done!");
} catch (error) {
  console.error(error);
  process.exit(1);
}
