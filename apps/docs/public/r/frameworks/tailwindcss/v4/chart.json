{
  "$schema": "https://shadcn-solid.com/schema/registry-item.json",
  "name": "chart",
  "type": "registry:ui",
  "dependencies": [
    "@unovis/solid"
  ],
  "files": [
    {
      "path": "src/ui/v4/chart.tsx",
      "content": "import {\n  For,\n  Match,\n  Show,\n  Switch,\n  createContext,\n  mergeProps,\n  splitProps,\n  useContext,\n  type JSX,\n} from \"solid-js\"\nimport { render } from \"solid-js/web\"\nimport type { VisCrosshairProps } from \"@unovis/solid\"\nimport {\n  VisCrosshair,\n  VisSingleContainer,\n  VisXYContainer,\n  type VisSingleContainerProps,\n  type VisXYContainerProps,\n} from \"@unovis/solid\"\n\nimport { cx } from \"@repo/tailwindcss/utils/cva\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: '[data-kb-theme=\"dark\"]' } as const\n\nexport type ChartConfig = Record<\n  string,\n  {\n    label?: JSX.Element\n    icon?: JSX.Element\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n>\n\ninterface ChartContextProps {\n  config: ChartConfig\n}\n\nconst ChartContext = createContext<ChartContextProps>()\n\nconst useChart = () => {\n  const context = useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\ntype SingleContainerProps<T> = VisSingleContainerProps<T> & {\n  type: \"single\"\n}\n\ntype XYContainerProps<T> = VisXYContainerProps<T> & {\n  type: \"xy\"\n}\n\nexport type ChartContainerProps<T> = (\n  | XYContainerProps<T>\n  | SingleContainerProps<T>\n) &\n  ChartContextProps\n\nexport const ChartContainer = <T,>(props: ChartContainerProps<T>) => {\n  const [, rest] = splitProps(props, [\"config\", \"children\", \"type\", \"class\"])\n\n  return (\n    <ChartContext.Provider\n      value={{\n        get config() {\n          return props.config\n        },\n      }}\n    >\n      <div\n        data-slot=\"chart\"\n        class={cx(\"flex aspect-video justify-center\", props.class)}\n      >\n        <Switch>\n          <Match when={props.type === \"xy\"}>\n            <VisXYContainer {...(rest as Omit<XYContainerProps<T>, \"type\">)}>\n              <ChartStyle type=\"xy\" config={props.config} />\n              {props.children}\n            </VisXYContainer>\n          </Match>\n\n          <Match when={props.type === \"single\"}>\n            <VisSingleContainer\n              {...(rest as Omit<SingleContainerProps<T>, \"type\">)}\n            >\n              <ChartStyle type=\"single\" config={props.config} />\n              {props.children}\n            </VisSingleContainer>\n          </Match>\n        </Switch>\n      </div>\n    </ChartContext.Provider>\n  )\n}\n\nexport type ChartStyleProps = {\n  type: \"xy\" | \"single\"\n} & Omit<ChartContextProps, \"data\">\n\nexport const ChartStyle = (props: ChartStyleProps) => {\n  const colorConfig = () =>\n    Object.entries(props.config).filter(\n      ([, config]) => config.theme ?? config.color,\n    )\n\n  return (\n    <Show when={colorConfig().length}>\n      <style>\n        {Object.entries(THEMES)\n          .map(([theme, prefix]) => {\n            const colorVars = colorConfig()\n              .map(([key, itemConfig]) => {\n                const color =\n                  itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ??\n                  itemConfig.color\n                return color ? `  --color-${key}: ${color};` : null\n              })\n              .join(\"\\n\")\n\n            return `${prefix} [data-vis-${props.type}-container] {\\n${colorVars}\\n}`\n          })\n          .join(\"\\n\\n\")}\n      </style>\n    </Show>\n  )\n}\n\nexport type ChartCrosshairProps<T> = Omit<VisCrosshairProps<T>, \"template\"> & {\n  template?: (\n    props: {\n      data: T\n      x: number | Date\n    } & ChartContextProps,\n  ) => JSX.Element\n}\n\nexport const ChartCrosshair = <T,>(props: ChartCrosshairProps<T>) => {\n  const [, rest] = splitProps(props, [\"template\"])\n  const { config } = useChart()\n\n  const template = (d: T, x: number | Date) => {\n    const container = document.createElement(\"div\")\n    const Component = () =>\n      !props.template ? null : props.template({ data: d, x, config })\n    render(() => <Component />, container)\n    return container.innerHTML\n  }\n\n  return <VisCrosshair template={template} {...rest} />\n}\n\ntype InferLabelKey<T, C> = C extends ChartConfig\n  ? ChartConfig extends C\n    ? keyof T\n    : keyof C\n  : never\n\nconst getConfigFromData = <T, C extends ChartConfig = ChartConfig>(\n  data: T,\n  config: ChartConfig,\n  labelKey?: InferLabelKey<T, C>,\n  nameKey?: C extends undefined ? never : keyof C,\n) => {\n  const valueKeys =\n    // @ts-expect-error\n    Object.entries(data)\n      .filter(\n        ([key, value]) =>\n          key !== labelKey &&\n          (typeof value === \"number\" || typeof value === \"object\"),\n      )\n      .filter(([key]) => !key.includes(\"_\"))\n      .map(([key]) => key)\n\n  const items = valueKeys.map((key) => {\n    const configItem = config[key]\n    let color = configItem.color\n\n    // @ts-expect-error\n    if (!color && \"fill\" in data) {\n      color = data.fill as string\n    }\n\n    const rawValue = data[key as keyof T]\n    const value =\n      typeof rawValue === \"object\" && rawValue !== null\n        ? Object.values(rawValue).find((v) => typeof v === \"number\")\n        : (rawValue as number)\n\n    return {\n      value,\n      key: nameKey ? config[nameKey].label : configItem.label,\n      icon: configItem.icon,\n      color,\n    }\n  })\n\n  const label = data[labelKey as keyof T] ?? config[labelKey as keyof C].label\n\n  return {\n    label,\n    items,\n  }\n}\n\nexport type ChartTooltipContentProps<T, C extends ChartConfig = ChartConfig> = {\n  data: T\n  x: number | Date\n  labelKey: InferLabelKey<T, C>\n  class?: string\n  hideLabel?: boolean\n  hideIndicator?: boolean\n  indicator?: \"line\" | \"dot\" | \"dashed\"\n  nameKey?: C extends undefined ? never : keyof C\n  labelFormatter?: (data: number | Date) => JSX.Element\n  labelAsKey?: boolean\n  formatter?: (\n    value: number,\n    name: JSX.Element,\n    item: T,\n    index: number,\n  ) => JSX.Element\n} & ChartContextProps\n\nexport const ChartTooltipContent = <T, C extends ChartConfig = ChartConfig>(\n  props: ChartTooltipContentProps<T, C>,\n) => {\n  const merge = mergeProps(\n    {\n      hideLabel: false,\n      hideIndicator: false,\n      indicator: \"dot\",\n      labelAsKey: false,\n    } satisfies Partial<ChartTooltipContentProps<T, C>>,\n    props,\n  )\n\n  const value = () =>\n    getConfigFromData<T, C>(\n      merge.data,\n      merge.config,\n      merge.labelKey,\n      merge.nameKey,\n    )\n\n  const tooltipLabel = () => {\n    if (merge.hideLabel || !value().items.length) {\n      return null\n    }\n\n    return (\n      <div class=\"font-medium capitalize\">\n        <Show\n          when={!merge.labelFormatter}\n          fallback={merge.labelFormatter!(\n            typeof merge.x === \"number\" ? Math.round(merge.x) : merge.x,\n          )}\n        >\n          {value().label as JSX.Element}\n        </Show>\n      </div>\n    )\n  }\n\n  const nestLabel = () =>\n    value().items.length === 1 && merge.indicator !== \"dot\"\n\n  return (\n    <div\n      class={cx(\"grid min-w-[8rem] items-start gap-1.5 text-xs\", merge.class)}\n    >\n      <Show when={!nestLabel()}>{tooltipLabel()}</Show>\n      <div class=\"grid gap-1.5\">\n        <For each={value().items}>\n          {(item, index) => (\n            <div\n              class={cx(\n                \"[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:size-2.5\",\n                merge.indicator === \"dot\" && \"items-center\",\n              )}\n            >\n              <Show\n                when={!merge.formatter}\n                fallback={merge.formatter!(\n                  item.value!,\n                  item.key,\n                  merge.data,\n                  index(),\n                )}\n              >\n                <Show when={item.icon}>{item.icon}</Show>\n                <Show when={!item.icon && !merge.hideIndicator}>\n                  <div\n                    class={cx(\n                      \"border-(--color-border) bg-(--color-bg) shrink-0 rounded-[2px]\",\n                      {\n                        \"size-2.5\": merge.indicator === \"dot\",\n                        \"w-1\": merge.indicator === \"line\",\n                        \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                          merge.indicator === \"dashed\",\n                        \"my-0.5\": nestLabel() && merge.indicator === \"dashed\",\n                      },\n                    )}\n                    style={{\n                      \"--color-border\": item.color,\n                      \"--color-bg\": item.color,\n                    }}\n                  />\n                </Show>\n                <div\n                  class={cx(\n                    \"flex flex-1 justify-between gap-1.5 leading-none\",\n                    nestLabel() ? \"items-end\" : \"items-center\",\n                  )}\n                >\n                  <div class=\"grid gap-1.5\">\n                    <Show when={nestLabel()}>{tooltipLabel()}</Show>\n                    <span class=\"text-muted-foreground capitalize\">\n                      <Show\n                        when={!merge.labelAsKey}\n                        fallback={value().label as string}\n                      >\n                        {item.key}\n                      </Show>\n                    </span>\n                  </div>\n                  <span class=\"text-foreground font-mono font-medium tabular-nums\">\n                    {item.value}\n                  </span>\n                </div>\n              </Show>\n            </div>\n          )}\n        </For>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}