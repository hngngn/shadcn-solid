import { readFileSync, readdirSync, statSync, writeFileSync } from "node:fs"
import { join, resolve } from "node:path"
import GithubSlugger from "github-slugger"
import grayMatter from "gray-matter"
import { fromMarkdown } from "mdast-util-from-markdown"
import { mdxFromMarkdown } from "mdast-util-mdx"
import { mdxjs } from "micromark-extension-mdxjs"
import { rimraf } from "rimraf"
import { visit } from "unist-util-visit"
import type { Plugin } from "vite"

const folderPath = "./src/content/docs"

const generateContents = (folderPath: string) => {
  const contents: {
    component: string
    data: Record<string, string>
    headings: {
      depth: number
      slug: string
      text: string
    }[]
  }[] = []

  const slugger = new GithubSlugger()

  readdirSync(folderPath).forEach((file) => {
    const filePath = join(folderPath, file)

    if (statSync(filePath).isDirectory()) {
      const subdirectoryContents = generateContents(filePath)
      contents.push(...subdirectoryContents)
    } else {
      if (file.endsWith(".mdx")) {
        const componentPath = filePath.replace(/src/g, "@").replace(/\\/g, "/")
        const fileContent = readFileSync(filePath, "utf-8")

        const { data, content } = grayMatter(fileContent)

        const tree = fromMarkdown(content, {
          extensions: [mdxjs()],
          mdastExtensions: [mdxFromMarkdown()],
        })

        const headings: { depth: number; slug: string; text: string }[] = []

        const usedSlugs = new Map<string, number>()

        visit(tree, "heading", (node) => {
          const value = node.children
            .filter((i) => i.type === "text" || i.type === "inlineCode")
            .map((i) => i.value)
            .join("")

          // Normalize value and slug base
          let baseSlug = slugger.slug(value)

          // Remove trailing -<number> if present
          const match = baseSlug.match(/(.*)-(\d+)$/)
          if (match) {
            baseSlug = match[1]
          }

          // Track duplicates
          const count = usedSlugs.get(baseSlug) ?? 0
          usedSlugs.set(baseSlug, count + 1)

          const finalSlug = count === 0 ? baseSlug : `${baseSlug}-${count}`

          headings.push({
            depth: node.depth,
            text: value,
            slug: finalSlug,
          })
        })

        contents.push({ component: componentPath, data, headings })
      }
    }
  })

  return contents
}

const generateRouteKey = (filePath: string): string =>
  filePath.replace(/@\/content\/docs\//, "").replace(/\.mdx$/, "")

const generateContentsFile = () => {
  const contentsArray = generateContents(folderPath)

  const formattedContents = contentsArray
    .map(
      (item) =>
        `  "${generateRouteKey(item.component)}": {\n    component: lazy(() => import("${
          item.component
        }")),\n    data: ${JSON.stringify(item.data, null, 2)},\n    headings: ${JSON.stringify(item.headings, null, 2)}\n  },`,
    )
    .join("\n")

  const fileContent = `// @ts-nocheck
// This file is autogenerated
// Do not edit this file directly.
import type { JSX } from "solid-js";
import { lazy } from "solid-js";

interface Content {
  component: JSX.Element
  data: {
    title: string
    description: string
    component?: boolean
    link?: {
      doc?: string
      api?: string
    }
    toc?: boolean 
  } 
  headings: {
    depth: number
    slug: string
    text: string
  }[]
}

export const Contents : Record<string, Content> = {\n${formattedContents}\n};`

  rimraf.sync(resolve("src/content/index.ts"))
  writeFileSync(resolve("src/content/index.ts"), fileContent)
}

export default (): Plugin => {
  return {
    name: "content",
    buildStart() {
      generateContentsFile()
    },
    configureServer(server) {
      server.watcher.on("change", (path) => {
        if (path.endsWith(".mdx")) {
          generateContentsFile()
        }
      })
    },
  }
}
