import fs from "node:fs"
import { tmpdir } from "node:os"
import path from "node:path"
import { rimraf } from "rimraf"
import { Project, ScriptKind } from "ts-morph"

import { frameworks } from "@/registry/frameworks"
import type { Registry } from "@/registry/schema"

const project = new Project({
  compilerOptions: {},
})

const createTempSourceFile = (filename: string) => {
  const dir = fs.mkdtempSync(path.join(tmpdir(), "shadcn-"))
  return path.join(dir, filename)
}

const fixImport = (content: string) => {
  const regex = /@\/(.+?)\/((?:.*?\/)?(?:components|ui|hooks|lib))\/([\w-]+)/g

  const replacement = (
    match: string,
    _path: string,
    type: string,
    component: string,
  ) => {
    if (type.endsWith("components")) {
      return `@/components/${component}`
    }
    if (type.endsWith("ui")) {
      return `@/components/ui/${component}`
    }
    if (type.endsWith("hooks")) {
      return `@/hooks/${component}`
    }
    if (type.endsWith("lib")) {
      return `@/lib/${component}`
    }

    return match
  }

  return content.replace(regex, replacement)
}

const getFileContent = (filePath: string) => {
  const raw = fs.readFileSync(filePath, "utf-8")

  const project = new Project({
    compilerOptions: {},
  })

  const tempFile = createTempSourceFile(filePath)
  const sourceFile = project.createSourceFile(tempFile, raw, {
    scriptKind: ScriptKind.TSX,
  })

  let code = sourceFile.getFullText()

  // Fix imports.
  code = fixImport(code)

  return JSON.stringify(code, null, 4)
}

// Helper function to create valid component name from item name
const createComponentName = (itemName: string) => {
  return itemName
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("")
}

export const buildRegistry = (registry: Registry) => {
  let componentImports = `// @ts-nocheck
// This file is autogenerated by scripts/index.ts
// Do not edit this file directly.
import clientOnlyWrapper from "@/components/client-only-wrapper"

`

  let index = `export const Index: Record<string, any> = {
  `

  // Collect all components for imports
  const componentMap = new Map<string, { name: string; path: string }>()

  for (const framework of frameworks) {
    // we don't render any of component or example of `unocss`
    if (framework.name === "unocss") {
      break
    }

    index += ` "${framework.name}": {`

    // Build style index.
    for (const item of registry.items) {
      // we only need `example` and `block`
      if (item.type === "registry:example" || item.type === "registry:block") {
        const resolveFiles = item.files?.map(
          (file) =>
            `../../packages/${framework.name}/src/${
              typeof file === "string" ? file : file.path
            }`,
        )

        if (!resolveFiles) {
          continue
        }

        const type = item.type.split(":")[1]
        let sourceFilename = ""
        let componentPath = `@repo/${framework.name}/${type}/${item.name}`

        if (item.type === "registry:block") {
          const file = resolveFiles[0]
          const filename = path.basename(file)

          let raw: string
          try {
            raw = fs.readFileSync(file, "utf8")
          } catch {
            continue
          }

          const tempFile = createTempSourceFile(filename)
          const sourceFile = project.createSourceFile(tempFile, raw, {
            scriptKind: ScriptKind.TSX,
          })

          // Find all imports.
          const imports = new Map<
            string,
            {
              module: string
              text: string
              isDefault?: boolean
            }
          >()

          for (const node of sourceFile.getImportDeclarations()) {
            const module = node.getModuleSpecifier().getLiteralValue()

            for (const item of node.getNamedImports()) {
              imports.set(item.getText(), {
                module,
                text: node.getText(),
              })
            }

            const defaultImport = node.getDefaultImport()
            if (defaultImport) {
              imports.set(defaultImport.getText(), {
                module,
                text: defaultImport.getText(),
                isDefault: true,
              })
            }
          }

          // Write the source file for blocks only.
          sourceFilename = `__registry__/${framework.name}/${type}/${item.name}.tsx`

          if (item.files) {
            const files = item.files.map((file) =>
              typeof file === "string"
                ? { type: "registry:page", path: file }
                : file,
            )

            if (files.length) {
              sourceFilename = `src/__registry__/${framework.name}/${files[0].path}`
            }
          }
        }

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file,
          )

          if (files.length) {
            componentPath = `@repo/${framework.name}/${files[0].path.slice(0, -4)}`
          }
        }

        // Create component name and store mapping
        const componentName = createComponentName(item.name)
        const componentKey = `${framework.name}_${item.name}`
        componentMap.set(componentKey, {
          name: componentName,
          path: componentPath,
        })

        index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `../../packages/${framework.name}/src/${
          typeof file === "string" ? file : file.path
        }`
        const resolvedFilePath = path.resolve(filePath)
        const content = getFileContent(filePath)

        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}",
        content: ${item.type === "registry:block" ? content : '""'}
      }`
      })}],
      component: () => <${componentName} />,
      source: "${sourceFilename}"
    },`
      }
    }

    index += `
  },`
  }

  index += `
  }
  `

  // Generate component imports
  for (const [, componentInfo] of componentMap) {
    componentImports += `const ${componentInfo.name} = clientOnlyWrapper(() => import("${componentInfo.path}"), { lazy: true })\n`
  }
  componentImports += "\n"

  const finalIndex = componentImports + index

  // Write style index.
  if (!fs.existsSync(path.join(process.cwd(), "src/__registry__"))) {
    fs.mkdirSync(path.join(process.cwd(), "src/__registry__"), {
      recursive: true,
    })
  }

  rimraf.sync(path.join(process.cwd(), "src/__registry__/index.tsx"))
  fs.writeFileSync(
    path.join(process.cwd(), "src/__registry__/index.tsx"),
    finalIndex,
  )
}
